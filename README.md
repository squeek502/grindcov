grindcov
========

Basic code coverage generation tool using [Callgrind](https://valgrind.org/docs/manual/cl-manual.html) (via Valgrind). Created with [Zig](https://ziglang.org/) code in mind, but should work for any compiled binary with debug information.

The output is a directory with `.diff` files for each source file instrumented by callgrind, with either a `! ` (not executed) or a `> ` (executed) prefix for every line of source code (the `.diff` and `!`/`>` prefixes are just so that code editors syntax highlight the results in an understandable way).

Example (note: contents of `main.zig` omitted here, the source can be seen in the output):

```sh
$ zig build-exe main.zig
$ grindcov -- ./main
Results for 1 source files generated in directory 'coverage'
$ ls coverage
main.zig.diff
```

`main.zig.diff` then contains:

```diff
! const std = @import("std");
! 
> pub fn main() !void {
!     if (true) {
>         std.debug.print("yes\n", .{});
!     } else {
!         std.debug.print("no\n", .{});
!     }
! }
```

## Building / Installation

Requires latest master of Zig. Currently only tested on Linux.

1. Clone this repository and its submodules (`git clone --recursive` to get submodules)
2. `zig build`
3. The compiled binary will be in `zig-out/bin/grindcov`
4. `mv` or `ln` the binary somewhere in your `PATH`

## Usage

```
Usage: grindcov [options] -- <cmd> [<args>...]

Available options:
	-h, --help                	Display this help and exit.
	    --root <PATH>         	Root directory for source files.
	                          	- Files outside of the root directory are not reported on.
	                          	- Output paths are relative to the root directory.
	                          	(default: '.')
	    --output-dir <PATH>   	Directory to put the results. (default: './coverage')
	    --cwd <PATH>          	Directory to run the valgrind process from. (default: '.')
	    --keep-out-file       	Do not delete the callgrind file that gets generated.
	    --out-file-name <PATH>	Set the name of the callgrind.out file.
	                          	(default: 'callgrind.out.%p')
	    --include <PATH>...   	Include the specified callgrind file(s) when generating
	                          	coverage (can be specified multiple times).
	    --skip-collect        	Skip the callgrind data collection step.
	    --skip-report         	Skip the coverage report generation step.
```

### Integrating with Zig

`grindcov` can be also used as a test executor by Zig's test runner via `--test-cmd` and `--test-cmd-bin`:

```
zig test file.zig --test-cmd grindcov --test-cmd -- --test-cmd-bin
```

This can be integrated with `build.zig` by doing:

```zig
const coverage = b.option(bool, "test-coverage", "Generate test coverage with grindcov") orelse false;

var tests = b.addTest("test.zig");
if (coverage) {
    tests.setExecCmd(&[_]?[]const u8{
        "grindcov",
        "--",
        null, // to get zig to use the --test-cmd-bin flag
    });
}

const test_step = b.step("test", "Run all tests");
test_step.dependOn(&tests.step);
```

Test coverage information can then be generated by doing:
```
zig build test -Dcoverage
```

## How it works

This tool is mostly a convenience wrapper for a two step process:

- Generating a callgrind output file via `valgrind --tool=callgrind --compress-strings=no --compress-pos=no --collect-jumps=yes` (the flags are mostly used to make it easier to parse)
- Parsing the callgrind file, generating a set of all lines executed, and outputting that in a human-readable format

The idea comes from [numpy's c_coverage tool](https://github.com/numpy/numpy/tree/main/tools/c_coverage), which works pretty much identically (with a tiny bit of C/numpy specific stuff).

## Limitations

Stuff that might be possible but isn't supported right now:
- Non-Linux platform support (Valgrind must support the platform, though)
- Support for following child processes spawned by the instrumented process
- More output formats

Stuff that I don't think is possible but that I might be wrong about:
- Outputting [`lcov`-compatible tracefiles (`.info`)](https://manpages.debian.org/stretch/lcov/geninfo.1.en.html#FILES)--AFAIK callgrind doesn't give any information about instrumented-but-not-executed lines, which `lcov` appears to require.
- A non-useless 'percentage covered' statistic, for the same reason as the 'AFAIK' statement in the previous bullet point. I think `comptime` execution especially makes something like this tricky in general. The only thing I can think of is that it might be possible to parse the binary and get a list of all lines of source code that actually made it into the final binary, and then use that as the denominator to calculate a coverage percentage.
